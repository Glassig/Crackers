\section{The Game}
The game is inspired by the previously mentioned Zork. It consists of a few rooms and tasks to be performed before reaching a victory scenario. The game differs in environments and plot between the different implementations of NLIs, which requires the user to input different commands in order to win. One version uses typing to control your characterâ€™s actions and the other uses speech. The reason we decided to create two implementations is so that a user who has played one control-scheme could still play the other without having the benefit of knowing what is required to win.

\subsection{Plot}
The user play as a bunny that has escaped its cage and is on the hunt for food. They need to eat three crackers in each game in order to ease their hunger and win the game. In the speech version the user is a house-pet and is in an apartment and has the ability to be in the kitchen, the livingroom and the bedroom. In the text version they are a class-pet in a school and can visit the classroom, the hallway and the cafeteria.

\section{Implementation}
Short introduction to that the game uses existing libraries to handle different things.

\subsection{Programming Language}
Javaaaaaaa *rykande tekopp*

\subsection{Stanford POSTagger}
Text about Stanford POSTagger.

\subsection{Sphinx4}
Text about Sphinx4.

\section{Evaluation}
Metatext?

\subsection{User Testing}
Users tested both versions of the game so that each of the score given could be compared. Each game starts with an introductory text, explaining how to play the game, the basic structure of commands and that the user should try using synonyms if stuck at any point. It also explains the goal and the name of all the rooms. This is the only thing the user is told before they start inputting commands. While they play they might only be given hints if the user is stuck at some point for quite a while. Examples of these hints are ``speak clearer'', ``try synonyms'' or ``input should be at least a verb and a noun''.

Before the user plays any game, they fill in a form asking for their personal data, how well they would rate their spoken and written english and if they have any speech impediment. The user then plays one version of the game and after fills in the ``System Usability Scale''-questionnaire detailed in \ref{usability}. They then plays the other version and once again fills in the questionnaire. The game the user starts to play is varied between the users, so that almost half of the testers started with speech and half with text.

While the user plays the game records each command and how many commands is used. When the user is done this data gets saved to a file that is later done for analyzis.

\subsection{System Usability Scale}
Using the System Usability Scale as described in \ref{usability}, a score for each system is calculated. However, since all the odd questions are ``positive statements'' (for example ``I think that I would like to use this sytem frequently'') while all the even questions are ``negative statemens'' (such as ``I found the system unnecessarily complex'') in nature, they have to be converted in order to make them work together. This is done as follows: 
\[
    f_{i} = 
\begin{cases}
    5 - Q_{i}, & \text{when i is even}\\
    Q_{i} - 1, & \text{when i is odd}
\end{cases}
\]
Where \(Q_{i} \) is the answer to question numbered i. The total point is then: 
\[ 2.5 * \displaystyle \sum_{i=1}^{10} f_{i} \]
The score lies in the range 0-100. A high score means that the system is easy to use and liked by the users, while a low score means that it should be improved before publishing. \citep{Broo}
