\section{The Game}
The game is inspired by the previously mentioned Zork. It consists of a few rooms and tasks to be performed before reaching a victory scenario. The game differs in environments and plot between the different implementations of NLIs, which requires the user to input different commands in order to win. One version uses typing to control your character’s actions and the other uses speech. The reason we decided to create two implementations is so that a user who has played one control-scheme could still play the other without having the benefit of knowing what is required to win.

\subsection{Plot}
The user play as a bunny that has escaped its cage and is on the hunt for food. They need to eat three crackers in each game in order to ease their hunger and win the game. In the speech version the user is a house-pet and is in an apartment and has the ability to be in the kitchen, the livingroom and the bedroom. In the text version they are a class-pet in a school and can visit the classroom, the hallway and the cafeteria.

\section{Implementation}
Short introduction to that the game uses existing libraries to handle different things.

\subsection{Programming Language}
Javaaaaaaa *rykande tekopp*

\subsection{Stanford POSTagger}
Text about Stanford POSTagger.

\subsection{Sphinx4}
Text about Sphinx4.

\section{Evaluation}
Metatext?

\subsection{User Testing}
Users tested both versions of the game in order to compare them. First we explain to them the basics of a text-adventure: there is a description of the room you are in, you type or say simple commands in natural language in order to do things and sometimes must interact with your surroundings in order to progress. 

The user gets to play one of the game-versions and upon completion they will answer a short form that will be expanded upon in the following section: “System Usability Scale”(SECTION x.y). Various data was recorded, such as amount of commands, completion time and if there were anything specific that the user failed on multiple times. The last check is in case we require the users to say a certain word or phrase at one part but the game has a hard time parsing the command for each user. This is done in an attempt to filter out bad programming and game design on our part.

After the user played one version and filled in the questionnaire the user then played the other version and filled in the questionnaire again but with regard to the new control scheme. We repeated this test with multiple users and we alternated between which game version was to be played first.

\subsection{System Usability Scale}
ADD INTRO TEXT

All the odd questions are ``positive'' while all the even questions are ``negative'' in nature. In order to make them work together, we convert the points as follows: 
\[
    f_{i} = 
\begin{cases}
    5 - Q_{i}, & \text{when i is even}\\
    Q_{i} - 1, & \text{when i is odd}
\end{cases}
\]
Where \(Q_{i} \) is the answer to question numbered i. The total point is then: 
\[ 2.5 * \displaystyle \sum_{i=1}^{10} f_{i} \]
The score lies in the range 0-100. A high score means that the system is easy to use and liked by the users, while a low score means that it should be improved before publishing. \citep{Broo}
